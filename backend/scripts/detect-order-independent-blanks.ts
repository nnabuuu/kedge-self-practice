#!/usr/bin/env tsx
/**
 * Detect and Fix Order-Independent Blanks in Fill-in-the-Blank Questions
 *
 * This script detects fill-in-the-blank quizzes where blanks are semantically
 * interchangeable (e.g., parallel items, coordinate concepts) and adds
 * cross-referenced alternative answers to allow students to answer in any order.
 *
 * Problem it solves:
 * - Question: "ÂåóÂÆãÂíåÂåóÊñπÁöÑ____„ÄÅ____ÊîøÊùÉ"
 * - Answer: ["ËæΩ", "Ë•øÂ§è"]
 * - Student writes: "Ë•øÂ§è„ÄÅËæΩ" (reversed order)
 * - Without this fix: ‚ùå Marked wrong
 * - With this fix: ‚úÖ Marked correct
 *
 * Requirements:
 * - Node.js 18+
 * - tsx (use npx or install globally)
 * - Backend API server running
 * - LLM API key configured
 *
 * Usage:
 *   source .envrc
 *   npx tsx scripts/detect-order-independent-blanks.ts
 *
 * Options:
 *   --dry-run            Preview changes without updating
 *   --limit=N            Process only first N quizzes
 *   --force              Re-analyze even if already has cross-referenced alternatives
 *   --jwt-token=TOKEN    JWT token for authentication
 *   --username=EMAIL     Teacher email for login
 *   --password=PASS      Teacher password for login
 *
 * Examples:
 *   # Dry run
 *   npx tsx scripts/detect-order-independent-blanks.ts --dry-run
 *
 *   # Process first 10 quizzes
 *   npx tsx scripts/detect-order-independent-blanks.ts --limit=10 --jwt-token=...
 *
 *   # Force re-analysis
 *   npx tsx scripts/detect-order-independent-blanks.ts --force --jwt-token=...
 */

import OpenAI from 'openai';
import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';
import 'dotenv/config';

// ============================================================================
// Configuration
// ============================================================================

interface Config {
  apiUrl: string;
  llmApiKey: string;
  llmModel: string;
  llmTemperature: number;
  llmMaxTokens: number;
  llmBaseUrl?: string;
  jwtToken: string;
}

interface ScriptOptions {
  dryRun: boolean;
  limit?: number;
  force: boolean;
  jwtToken?: string;
  username?: string;
  password?: string;
  apiUrl?: string;
}

interface QuizItem {
  id: string;
  type: string;
  question: string;
  answer: string | string[];
  alternative_answers?: string[];
  hints?: (string | null)[] | null;
}

interface OrderAnalysisResult {
  is_order_independent: boolean;
  interchangeable_pairs: number[][];  // e.g., [[0, 1], [2, 3]]
  reasoning: string;
}

interface ErrorRecord {
  quizId: string;
  question: string;
  answer: string | string[];
  error: string;
  timestamp: string;
}

// ============================================================================
// Authentication (reuse from generate-fill-blank-alternatives.ts)
// ============================================================================

function promptInput(question: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

function promptPassword(question: string): Promise<string> {
  return new Promise((resolve) => {
    const stdin = process.stdin;
    const stdout = process.stdout;

    let password = '';
    stdout.write(question);
    stdin.setRawMode(true);
    stdin.resume();
    stdin.setEncoding('utf8');

    const onData = (char: string) => {
      switch (char) {
        case '\n':
        case '\r':
        case '\u0004':
          stdin.setRawMode(false);
          stdin.pause();
          stdin.removeListener('data', onData);
          stdout.write('\n');
          resolve(password);
          break;
        case '\u0003':
          stdin.setRawMode(false);
          process.exit();
          break;
        case '\u007f':
        case '\b':
          if (password.length > 0) {
            password = password.slice(0, -1);
            stdout.write('\b \b');
          }
          break;
        default:
          if (char.charCodeAt(0) >= 32 && char.charCodeAt(0) <= 126) {
            password += char;
            stdout.write('*');
          }
          break;
      }
    };

    stdin.on('data', onData);
  });
}

async function loginWithCredentials(apiUrl: string, username: string, password: string): Promise<string> {
  console.log(`\nüîê Logging in as ${username}...`);

  const response = await fetch(`${apiUrl}/v1/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email: username, password: password, role: 'teacher' }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Login failed: ${response.statusText} - ${errorText}`);
  }

  const data = await response.json();
  if (!data.token) {
    throw new Error('Login response missing token');
  }

  console.log('   ‚úÖ Login successful');
  return data.token;
}

async function getAuthToken(apiUrl: string, options: ScriptOptions): Promise<string> {
  if (options.jwtToken) {
    console.log('\nüîë Using JWT token from command line');
    return options.jwtToken;
  }

  if (options.username && options.password) {
    return loginWithCredentials(apiUrl, options.username, options.password);
  }

  console.log('\nüîê Authentication Required');
  console.log('   Choose method: 1=Token, 2=Login');
  const method = await promptInput('   Method (1/2): ');

  if (method === '1') {
    const token = await promptInput('   JWT token: ');
    if (!token.trim()) throw new Error('Token cannot be empty');
    return token.trim();
  } else if (method === '2') {
    const username = await promptInput('   Email: ');
    const password = await promptPassword('   Password: ');
    if (!username.trim() || !password.trim()) throw new Error('Credentials cannot be empty');
    return loginWithCredentials(apiUrl, username.trim(), password);
  } else {
    throw new Error('Invalid method');
  }
}

// ============================================================================
// Command Line Parsing
// ============================================================================

function parseArgs(): ScriptOptions {
  const args = process.argv.slice(2);
  const options: ScriptOptions = {
    dryRun: args.includes('--dry-run'),
    force: args.includes('--force'),
  };

  for (const arg of args) {
    if (arg.startsWith('--limit=')) options.limit = parseInt(arg.split('=')[1], 10);
    if (arg.startsWith('--jwt-token=')) options.jwtToken = arg.split('=')[1];
    if (arg.startsWith('--username=')) options.username = arg.split('=')[1];
    if (arg.startsWith('--password=')) options.password = arg.split('=')[1];
    if (arg.startsWith('--api-url=')) options.apiUrl = arg.split('=')[1];
  }

  return options;
}

async function loadConfig(options: ScriptOptions): Promise<Config> {
  const apiPort = process.env.API_PORT || '8718';
  const apiUrl = options.apiUrl || `http://localhost:${apiPort}`;
  const llmApiKey = process.env.LLM_API_KEY || '';
  const llmModel = process.env.LLM_MODEL_QUIZ_PARSER || 'gpt-4o';
  const llmTemperature = parseFloat(process.env.LLM_TEMP_QUIZ_PARSER || '0.1');
  const llmMaxTokens = parseInt(process.env.LLM_MAX_TOKENS_QUIZ_PARSER || '4000', 10);
  const llmBaseUrl = process.env.LLM_BASE_URL || undefined;

  if (!llmApiKey || llmApiKey === 'your-llm-api-key-here') {
    throw new Error('LLM_API_KEY not set');
  }

  const jwtToken = await getAuthToken(apiUrl, options);

  return { apiUrl, llmApiKey, llmModel, llmTemperature, llmMaxTokens, llmBaseUrl, jwtToken };
}

// ============================================================================
// Error Tracking
// ============================================================================

function saveErrorRecords(errors: ErrorRecord[]): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
  const filename = `order-independent-errors-${timestamp}.json`;
  const filepath = path.resolve(process.cwd(), filename);
  fs.writeFileSync(filepath, JSON.stringify(errors, null, 2), 'utf-8');
  return filepath;
}

// ============================================================================
// API Operations
// ============================================================================

async function fetchMultiBlankQuizzes(apiUrl: string, jwtToken: string, options: ScriptOptions): Promise<QuizItem[]> {
  console.log('\nüìä Fetching multi-blank fill-in-the-blank quizzes...');

  const headers = { 'Authorization': `Bearer ${jwtToken}` };
  let page = 1;
  const limit = 100;
  const allQuizzes: QuizItem[] = [];

  while (true) {
    const url = `${apiUrl}/v1/quiz?page=${page}&limit=${limit}&type=fill-in-the-blank`;
    const response = await fetch(url, { headers });

    if (!response.ok) {
      throw new Error(`Failed to fetch quizzes: ${response.statusText}`);
    }

    const data = await response.json();
    const quizzes = data.data || [];
    allQuizzes.push(...quizzes);

    if (quizzes.length < limit) break;
    page++;
    if (options.limit && allQuizzes.length >= options.limit) break;
  }

  // Filter to only multi-blank quizzes
  const multiBlankQuizzes = allQuizzes.filter(quiz => {
    const answer = Array.isArray(quiz.answer) ? quiz.answer : [quiz.answer];
    return answer.length > 1;
  });

  const result = options.limit ? multiBlankQuizzes.slice(0, options.limit) : multiBlankQuizzes;
  console.log(`‚úÖ Found ${result.length} multi-blank quizzes`);

  return result;
}

function hasConjunctions(question: string): boolean {
  // Check if question contains conjunctions that might indicate parallel blanks
  const conjunctions = ['Âíå', '‰∏é', '‰ª•Âèä', '„ÄÅ'];
  return conjunctions.some(conj => question.includes(conj));
}

function needsAnalysis(quiz: QuizItem, force: boolean): boolean {
  if (force) return true;

  // Pre-filter: Only analyze if question contains conjunctions (saves tokens)
  if (!hasConjunctions(quiz.question)) {
    return false;
  }

  // Check if already has cross-referenced alternatives
  const answer = Array.isArray(quiz.answer) ? quiz.answer : [quiz.answer];
  const alternatives = quiz.alternative_answers || [];

  // Check if any alternative has position prefix from another blank
  for (let i = 0; i < answer.length; i++) {
    for (let j = 0; j < answer.length; j++) {
      if (i !== j) {
        const crossRef = `[${i}]${answer[j]}`;
        if (alternatives.includes(crossRef)) {
          return false; // Already has cross-reference
        }
      }
    }
  }

  return true;
}

async function updateQuizViaAPI(apiUrl: string, jwtToken: string, quizId: string, alternatives: string[]): Promise<void> {
  const response = await fetch(`${apiUrl}/v1/quiz/${quizId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${jwtToken}`,
    },
    body: JSON.stringify({ alternative_answers: alternatives }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to update quiz: ${response.statusText} - ${errorText}`);
  }
}

// ============================================================================
// GPT Analysis
// ============================================================================

function buildAnalysisPrompt(quiz: QuizItem): string {
  const answer = Array.isArray(quiz.answer) ? quiz.answer : [quiz.answer];

  return `‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑ‰∏≠Â≠¶ÊïôËÇ≤‰∏ìÂÆ∂„ÄÇËØ∑ÂàÜÊûê‰ª•‰∏ãÂ°´Á©∫È¢òÔºåÂà§Êñ≠ÂêÑÁ©∫Ê†º‰πãÈó¥ÊòØÂê¶ÂèØ‰ª•‰∫íÊç¢È°∫Â∫è„ÄÇ

## Â°´Á©∫È¢ò‰ø°ÊÅØ
**È¢òÁõÆ**: ${quiz.question}
**Á≠îÊ°à**: ${JSON.stringify(quiz.answer)}

## Âà§Êñ≠Ê†áÂáÜ
ÂØπ‰∫éÂ§öÁ©∫Ê†ºÂ°´Á©∫È¢òÔºåÂà§Êñ≠ÂêÑÁ©∫Ê†º‰πãÈó¥ÊòØÂê¶Â≠òÂú®È°∫Â∫èË¶ÅÊ±ÇÔºö

‚úÖ **ÂèØ‰∫íÊç¢ÁöÑÊÉÖÂÜµ**ÔºàÂπ≥Á≠âÂπ∂ÂàóÂÖ≥Á≥ªÔºâÔºö
- Á≠îÊ°àÊòØÂπ≥Á≠âÁöÑÂπ∂ÂàóÂÖ≥Á≥ªÔºåÈ°∫Â∫è‰∏çÂΩ±ÂìçËØ≠‰πâ
- ‰æãÂ¶ÇÔºö"____Âíå____ÊîøÊùÉ" Á≠îÊ°àÔºö["ËæΩ", "Ë•øÂ§è"] ‚Üí ÂèØ‰∫íÊç¢
- ‰æãÂ¶ÇÔºö"____Âíå____ÊòØÈáçË¶ÅÂèëÊòé" Á≠îÊ°àÔºö["ÁÅ´ËçØ", "ÊåáÂçóÈíà"] ‚Üí ÂèØ‰∫íÊç¢

‚ùå **‰∏çÂèØ‰∫íÊç¢ÁöÑÊÉÖÂÜµ**ÔºàÊúâÊòéÁ°ÆÂÖ≥Á≥ªÊàñÈ°∫Â∫èÔºâÔºö
- Á≠îÊ°à‰πãÈó¥ÊúâÊòéÁ°ÆÁöÑ‰ªéÂ±û„ÄÅÂõ†Êûú„ÄÅÊó∂Â∫èÁ≠âÂÖ≥Á≥ª
- ‰æãÂ¶ÇÔºö"____ÁöÑ____Âéª‰∏ñ‰∫Ü" Á≠îÊ°àÔºö["Áà∑Áà∑", "Â≠ôÂ≠ê"] ‚Üí ‰∏çÂèØ‰∫íÊç¢
- ‰æãÂ¶ÇÔºö"‰ªé____Âà∞____" Á≠îÊ°àÔºö["1949", "1976"] ‚Üí ‰∏çÂèØ‰∫íÊç¢

## ‰ªªÂä°
1. ÂàÜÊûêÈ¢òÁõÆ‰∏≠ÂêÑÁ©∫Ê†ºÁöÑÁ≠îÊ°àÊòØÂê¶ÂèØ‰ª•‰∫íÊç¢È°∫Â∫è
2. Â¶ÇÊûúÂèØ‰ª•‰∫íÊç¢ÔºåÊåáÂá∫Âì™‰∫õÁ©∫Ê†º‰πãÈó¥ÂèØ‰ª•‰∫íÊç¢ÔºàÁî®Á¥¢ÂºïË°®Á§∫Ôºå‰ªé0ÂºÄÂßãÔºâ
3. Êèê‰æõÁÆÄÁü≠ÁöÑÂà§Êñ≠ÁêÜÁî±

## ËæìÂá∫Ê†ºÂºè
ËØ∑‰ª•JSONÊ†ºÂºèËøîÂõûÔºö

\`\`\`json
{
  "is_order_independent": true/false,
  "interchangeable_pairs": [[0, 1], [2, 3]],  // ÂèØ‰∫íÊç¢ÁöÑÁ©∫Ê†ºÂØπÔºåÂ¶ÇÊûú‰∏çÂèØ‰∫íÊç¢Âàô‰∏∫Á©∫Êï∞ÁªÑ
  "reasoning": "Âà§Êñ≠ÁêÜÁî±"
}
\`\`\`

Ê≥®ÊÑèÔºö
- interchangeable_pairs ÊòØ‰∫åÁª¥Êï∞ÁªÑÔºåÊØè‰∏™Â≠êÊï∞ÁªÑÂåÖÂê´ÂèØ‰ª•‰∫íÊç¢ÁöÑÁ©∫Ê†ºÁ¥¢Âºï
- Â¶ÇÊûúÊâÄÊúâÁ©∫Ê†ºÈÉΩÂèØ‰ª•‰ªªÊÑè‰∫íÊç¢ÔºåÂèØ‰ª•ÂàóÂá∫ÊâÄÊúâÁªÑÂêà
- Âè™ÊúâÁúüÊ≠£ËØ≠‰πâ‰∏äÂèØ‰ª•‰∫íÊç¢ÁöÑÊâçËøîÂõûtrueÔºå‰∏çÁ°ÆÂÆöÊó∂ËøîÂõûfalse`;
}

async function analyzeOrderIndependence(
  openai: OpenAI,
  config: Config,
  quiz: QuizItem
): Promise<OrderAnalysisResult> {
  const prompt = buildAnalysisPrompt(quiz);

  console.log(`  ü§ñ Analyzing with ${config.llmModel}...`);

  const completion = await openai.chat.completions.create({
    model: config.llmModel,
    messages: [
      {
        role: 'system',
        content: '‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑ‰∏≠Â≠¶ÊïôËÇ≤‰∏ìÂÆ∂ÔºåÊìÖÈïøÂàÜÊûêÈ¢òÁõÆÁöÑËØ≠‰πâÂÖ≥Á≥ªÂíåÈÄªËæëÁªìÊûÑ„ÄÇ',
      },
      {
        role: 'user',
        content: prompt,
      },
    ],
    temperature: config.llmTemperature,
    max_tokens: config.llmMaxTokens,
    response_format: { type: 'json_object' },
  });

  const responseText = completion.choices[0].message.content;
  if (!responseText) {
    throw new Error('Empty response from LLM');
  }

  const parsed = JSON.parse(responseText);
  return {
    is_order_independent: parsed.is_order_independent || false,
    interchangeable_pairs: parsed.interchangeable_pairs || [],
    reasoning: parsed.reasoning || '',
  };
}

// ============================================================================
// Main Processing
// ============================================================================

async function processQuiz(
  openai: OpenAI,
  config: Config,
  quiz: QuizItem,
  options: ScriptOptions,
  index: number,
  total: number
): Promise<boolean> {
  console.log(`\n[${index + 1}/${total}] Processing quiz: ${quiz.id}`);
  console.log(`  üìù Question: ${quiz.question.substring(0, 80)}${quiz.question.length > 80 ? '...' : ''}`);
  console.log(`  ‚úèÔ∏è  Answer: ${JSON.stringify(quiz.answer)}`);

  // Pre-filter check
  if (!options.force && !hasConjunctions(quiz.question)) {
    console.log(`  ‚è≠Ô∏è  Skipping - no conjunctions found (Âíå/‰∏é/‰ª•Âèä/„ÄÅ)`);
    return false;
  }

  if (!needsAnalysis(quiz, options.force)) {
    console.log(`  ‚è≠Ô∏è  Skipping - already has cross-referenced alternatives`);
    return false;
  }

  try {
    const analysis = await analyzeOrderIndependence(openai, config, quiz);

    console.log(`  üìä Analysis:`);
    console.log(`     Order-independent: ${analysis.is_order_independent}`);
    console.log(`     Interchangeable pairs: ${JSON.stringify(analysis.interchangeable_pairs)}`);
    console.log(`     Reasoning: ${analysis.reasoning}`);

    if (!analysis.is_order_independent || analysis.interchangeable_pairs.length === 0) {
      console.log(`  ‚ÑπÔ∏è  No order-independent blanks detected`);
      return false;
    }

    // Build new alternative_answers with cross-references
    const answer = Array.isArray(quiz.answer) ? quiz.answer : [quiz.answer];
    const existingAlts = quiz.alternative_answers || [];
    const newAlts = [...existingAlts];

    // Add cross-references for each interchangeable pair
    for (const [idx1, idx2] of analysis.interchangeable_pairs) {
      // Add answer[idx2] as alternative for position idx1
      const crossRef1 = `[${idx1}]${answer[idx2]}`;
      if (!newAlts.includes(crossRef1)) {
        newAlts.push(crossRef1);
      }

      // Add answer[idx1] as alternative for position idx2
      const crossRef2 = `[${idx2}]${answer[idx1]}`;
      if (!newAlts.includes(crossRef2)) {
        newAlts.push(crossRef2);
      }
    }

    console.log(`  ‚ú® New alternatives: ${JSON.stringify(newAlts)}`);

    if (options.dryRun) {
      console.log(`  üîç [DRY RUN] Would update via API`);
    } else {
      await updateQuizViaAPI(config.apiUrl, config.jwtToken, quiz.id, newAlts);
      console.log(`  üíæ Successfully updated via API`);
    }

    return true;
  } catch (error) {
    console.error(`  ‚ùå Error processing quiz ${quiz.id}:`, error);
    if (error instanceof Error) {
      console.error(`     ${error.message}`);
    }
    throw error;
  }
}

async function main() {
  console.log('üöÄ Order-Independent Blanks Detection & Fixer');
  console.log('='.repeat(70));

  const options = parseArgs();

  console.log('\n‚öôÔ∏è  Script Options:');
  console.log(`   Dry Run: ${options.dryRun ? 'Yes' : 'No'}`);
  console.log(`   Limit: ${options.limit || 'No limit'}`);
  console.log(`   Force: ${options.force ? 'Yes' : 'No'}`);

  console.log('\nüîß Loading configuration and authenticating...');
  const config = await loadConfig(options);
  console.log('   ‚úÖ Configuration loaded');

  const openai = new OpenAI({
    apiKey: config.llmApiKey,
    baseURL: config.llmBaseUrl,
  });

  const quizzes = await fetchMultiBlankQuizzes(config.apiUrl, config.jwtToken, options);

  if (quizzes.length === 0) {
    console.log('\n‚ö†Ô∏è  No multi-blank quizzes found.');
    return;
  }

  console.log('\nüîÑ Processing quizzes...');
  console.log('='.repeat(70));

  let updatedCount = 0;
  let skippedCount = 0;
  let errorCount = 0;
  const errorRecords: ErrorRecord[] = [];

  for (let i = 0; i < quizzes.length; i++) {
    const quiz = quizzes[i];

    try {
      const wasUpdated = await processQuiz(openai, config, quiz, options, i, quizzes.length);

      if (wasUpdated) {
        updatedCount++;
      } else {
        skippedCount++;
      }
    } catch (error) {
      errorCount++;
      const errorMessage = error instanceof Error ? error.message : String(error);

      errorRecords.push({
        quizId: quiz.id,
        question: quiz.question.substring(0, 100),
        answer: quiz.answer,
        error: errorMessage,
        timestamp: new Date().toISOString(),
      });
    }

    if (i < quizzes.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  let errorFilePath: string | undefined;
  if (errorRecords.length > 0) {
    errorFilePath = saveErrorRecords(errorRecords);
    console.log(`\nüíæ Error records saved to: ${errorFilePath}`);
  }

  console.log('\n' + '='.repeat(70));
  console.log('üìä Summary');
  console.log('='.repeat(70));
  console.log(`   Total quizzes: ${quizzes.length}`);
  console.log(`   ‚úÖ Updated: ${updatedCount}`);
  console.log(`   ‚è≠Ô∏è  Skipped: ${skippedCount}`);
  console.log(`   ‚ùå Errors: ${errorCount}`);

  if (errorCount > 0 && errorFilePath) {
    console.log(`\nüí° To retry errors: --retry-errors=${path.basename(errorFilePath)}`);
  }

  if (options.dryRun) {
    console.log('\nüîç Dry run completed. No changes made.');
  }

  console.log('\n‚úÖ Script completed!\n');
}

main().catch((error) => {
  console.error('\n‚ùå Fatal error:', error);
  if (error instanceof Error) {
    console.error(error.stack);
  }
  process.exit(1);
});
