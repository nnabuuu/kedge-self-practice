#!/usr/bin/env ts-node

/**
 * Quiz Image Validation Script
 *
 * This script scans all quizzes in the database to find image placeholders
 * and validates whether the referenced images exist in OSS (primary) or local filesystem.
 *
 * Supported image formats:
 * - New format: {{image:uuid}} - UUID-based image references
 * - Legacy format: {{img:N}} - Index-based references to images array
 *
 * Usage:
 *   ts-node validate-quiz-images.ts [options]
 *
 * Options:
 *   --verbose       Show detailed progress
 *   --json-only     Only output JSON report (no console summary)
 *   --help          Show this help message
 */

import * as fs from 'fs';
import * as path from 'path';
import { createPool, sql, DatabasePool } from 'slonik';

// Load environment variables from .env file (generated by direnv from .envrc + .envrc.override)
const dotenv = require('dotenv');

// eslint-disable-next-line @typescript-eslint/no-var-requires
const OSS = require('ali-oss');
const envFile = path.join(__dirname, '../.env');
if (fs.existsSync(envFile)) {
  dotenv.config({ path: envFile });
}

// Configuration from environment
const config = {
  databaseUrl: process.env.NODE_DATABASE_URL || '',
  storageRoot: process.env.QUIZ_STORAGE_PATH || './quiz-storage',
  verbose: process.argv.includes('--verbose'),
  jsonOnly: process.argv.includes('--json-only'),
  // OSS Configuration
  oss: {
    accessKeyId: process.env.ALIYUN_OSS_ACCESS_KEY_ID || '',
    accessKeySecret: process.env.ALIYUN_OSS_ACCESS_KEY_SECRET || '',
    bucket: process.env.ALIYUN_OSS_BUCKET || '',
    region: process.env.ALIYUN_OSS_REGION || '',
    endpoint: process.env.ALIYUN_OSS_ENDPOINT || '',
    pathPrefix: process.env.ALIYUN_OSS_PATH_PREFIX || 'quiz-attachments',
  },
  get ossEnabled() {
    return !!(this.oss.accessKeyId && this.oss.bucket);
  },
};

// Types
interface ImageReference {
  placeholder: string;
  type: 'new' | 'legacy';
  uuid?: string;
  index?: number;
  resolvedPath?: string;
  exists: boolean;
  existsInOSS: boolean;
  existsInLocal: boolean;
  localOnly: boolean;  // Warning: exists locally but not in OSS
  storageType?: 'oss' | 'filesystem' | 'none';
  fileSize?: number;   // File size in bytes (from OSS)
  corrupted?: boolean; // File exists but appears corrupted (too small)
  error?: string;
}

interface QuizValidationResult {
  quizId: string;
  question: string;
  imageReferences: ImageReference[];
  totalImages: number;
  validImages: number;
  missingImages: number;
  localOnlyImages: number;
  corruptedImages: number;
}

interface ValidationReport {
  timestamp: string;
  config: {
    storageRoot: string;
    ossEnabled: boolean;
    ossBucket: string;
    ossPathPrefix: string;
  };
  summary: {
    totalQuizzes: number;
    quizzesWithImages: number;
    quizzesWithMissingImages: number;
    quizzesWithLocalOnlyImages: number;
    quizzesWithCorruptedImages: number;
    totalImageReferences: number;
    validImages: number;
    missingImages: number;
    localOnlyImages: number;  // Warning count
    corruptedImages: number;  // Files that exist but are corrupted
  };
  details: QuizValidationResult[];
}

interface QuizRow {
  id: string;
  question: string;
  options: string[] | null;
  images: string[] | null;
}

// Common image extensions
const IMAGE_EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'pdf'];

// Minimum file size in bytes to consider a file valid (100 bytes)
// Files smaller than this are likely corrupted or empty
const MIN_VALID_FILE_SIZE = 100;

class QuizImageValidator {
  private pool: DatabasePool | null = null;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private ossClient: any = null;
  private report: ValidationReport;

  constructor() {
    this.report = {
      timestamp: new Date().toISOString(),
      config: {
        storageRoot: config.storageRoot,
        ossEnabled: config.ossEnabled,
        ossBucket: config.oss.bucket,
        ossPathPrefix: config.oss.pathPrefix,
      },
      summary: {
        totalQuizzes: 0,
        quizzesWithImages: 0,
        quizzesWithMissingImages: 0,
        quizzesWithLocalOnlyImages: 0,
        quizzesWithCorruptedImages: 0,
        totalImageReferences: 0,
        validImages: 0,
        missingImages: 0,
        localOnlyImages: 0,
        corruptedImages: 0,
      },
      details: [],
    };
  }

  /**
   * Initialize OSS client
   */
  private initOSS(): boolean {
    if (!config.ossEnabled) {
      console.error('‚ùå OSS not configured. Set ALIYUN_OSS_* environment variables.');
      return false;
    }

    try {
      this.ossClient = new OSS({
        accessKeyId: config.oss.accessKeyId,
        accessKeySecret: config.oss.accessKeySecret,
        bucket: config.oss.bucket,
        region: config.oss.region,
        endpoint: config.oss.endpoint,
        secure: true,
        timeout: 30000,
      });
      this.log('‚úÖ Connected to OSS');
      return true;
    } catch (error) {
      console.error('‚ùå Failed to initialize OSS client:', error);
      return false;
    }
  }

  /**
   * Initialize database connection
   */
  private async initDatabase(): Promise<boolean> {
    if (!config.databaseUrl) {
      console.error('‚ùå Database URL not configured. Set NODE_DATABASE_URL environment variable.');
      return false;
    }

    try {
      this.pool = await createPool(config.databaseUrl);
      this.log('‚úÖ Connected to database');
      return true;
    } catch (error) {
      console.error('‚ùå Failed to connect to database:', error);
      return false;
    }
  }

  /**
   * Log message if verbose mode is enabled
   */
  private log(message: string): void {
    if (config.verbose && !config.jsonOnly) {
      console.log(message);
    }
  }

  /**
   * Check if file exists in OSS and get its metadata
   */
  private async fileExistsInOSS(relativePath: string): Promise<{
    exists: boolean;
    size?: number;
    corrupted?: boolean;
  }> {
    if (!this.ossClient) return { exists: false };

    const ossPath = config.oss.pathPrefix
      ? `${config.oss.pathPrefix}/${relativePath}`
      : relativePath;

    try {
      const result = await this.ossClient.head(ossPath);
      const size = parseInt(result.res?.headers?.['content-length'] || '0', 10);
      const corrupted = size < MIN_VALID_FILE_SIZE;
      return { exists: true, size, corrupted };
    } catch (error: any) {
      if (error.code === 'NoSuchKey' || error.status === 404) {
        return { exists: false };
      }
      // Log other errors but don't throw
      this.log(`  OSS check error for ${ossPath}: ${error.message}`);
      return { exists: false };
    }
  }

  /**
   * Check if file exists in local filesystem
   */
  private async fileExistsInLocal(relativePath: string): Promise<boolean> {
    const fullPath = path.join(config.storageRoot, relativePath);
    try {
      await fs.promises.access(fullPath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Search for file by UUID in both OSS and local storage
   */
  private async findFileByUuid(uuid: string): Promise<{
    found: boolean;
    inOSS: boolean;
    inLocal: boolean;
    path?: string;
    fileSize?: number;
    corrupted?: boolean;
  }> {
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;

    // Search last 24 months
    for (let i = 0; i < 24; i++) {
      let year = currentYear;
      let month = currentMonth - i;

      while (month <= 0) {
        month += 12;
        year -= 1;
      }

      const monthStr = String(month).padStart(2, '0');

      // Try each extension
      for (const ext of IMAGE_EXTENSIONS) {
        const relativePath = `${year}/${monthStr}/${uuid}.${ext}`;

        const ossResult = await this.fileExistsInOSS(relativePath);
        const inLocal = await this.fileExistsInLocal(relativePath);

        if (ossResult.exists || inLocal) {
          return {
            found: true,
            inOSS: ossResult.exists,
            inLocal,
            path: relativePath,
            fileSize: ossResult.size,
            corrupted: ossResult.corrupted,
          };
        }
      }
    }

    return { found: false, inOSS: false, inLocal: false };
  }

  /**
   * Extract image references from text content
   */
  private extractImageReferences(
    text: string,
    imagesArray: string[] | null
  ): ImageReference[] {
    const refs: ImageReference[] = [];
    const seenPlaceholders = new Set<string>();

    // Extract new format: {{image:uuid}}
    const newFormatRegex = /\{\{image:([^}]+)\}\}/g;
    let match;

    while ((match = newFormatRegex.exec(text)) !== null) {
      const placeholder = match[0];
      if (!seenPlaceholders.has(placeholder)) {
        seenPlaceholders.add(placeholder);
        refs.push({
          placeholder,
          type: 'new',
          uuid: match[1],
          exists: false,
          existsInOSS: false,
          existsInLocal: false,
          localOnly: false,
        });
      }
    }

    // Extract legacy format: {{img:N}}
    const legacyFormatRegex = /\{\{img:(\d+)\}\}/g;

    while ((match = legacyFormatRegex.exec(text)) !== null) {
      const placeholder = match[0];
      if (!seenPlaceholders.has(placeholder)) {
        seenPlaceholders.add(placeholder);
        const index = parseInt(match[1], 10);
        const imageUrl = imagesArray && imagesArray[index];

        refs.push({
          placeholder,
          type: 'legacy',
          index,
          resolvedPath: imageUrl || undefined,
          exists: false,
          existsInOSS: false,
          existsInLocal: false,
          localOnly: false,
          error: !imageUrl ? `Index ${index} not found in images array` : undefined,
        });
      }
    }

    return refs;
  }

  /**
   * Parse image URL to extract relative storage path
   */
  private parseImageUrl(url: string): string | null {
    if (!url) return null;

    const patterns = [
      /\/v1\/attachments\/quiz\/(\d{4}\/\d{2}\/[^/]+)$/,
      /^\/v1\/attachments\/quiz\/(\d{4}\/\d{2}\/[^/]+)$/,
      /^\/attachments\/quiz\/(\d{4}\/\d{2}\/[^/]+)$/,
      /^(\d{4}\/\d{2}\/[a-f0-9-]+\.[a-z]+)$/i,
      /\/v1\/attachments\/([a-f0-9-]+\.[a-z]+)$/i,
      /^\/attachments\/([a-f0-9-]+\.[a-z]+)$/i,
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return match[1];
      }
    }

    const uuidPattern = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/i;
    const uuidMatch = url.match(uuidPattern);
    if (uuidMatch) {
      return uuidMatch[1]; // Return just UUID, will search with extensions
    }

    return null;
  }

  /**
   * Validate a single image reference
   */
  private async validateImageReference(
    ref: ImageReference,
    imagesArray: string[] | null
  ): Promise<ImageReference> {
    let searchResult: {
      found: boolean;
      inOSS: boolean;
      inLocal: boolean;
      path?: string;
      fileSize?: number;
      corrupted?: boolean;
    };

    if (ref.type === 'new' && ref.uuid) {
      searchResult = await this.findFileByUuid(ref.uuid);
    } else if (ref.type === 'legacy' && ref.resolvedPath) {
      const parsed = this.parseImageUrl(ref.resolvedPath);
      if (parsed) {
        // Check if it's a UUID or a full path
        if (parsed.includes('/')) {
          // Full path like 2025/01/uuid.png
          const ossResult = await this.fileExistsInOSS(parsed);
          const inLocal = await this.fileExistsInLocal(parsed);
          searchResult = {
            found: ossResult.exists || inLocal,
            inOSS: ossResult.exists,
            inLocal,
            path: parsed,
            fileSize: ossResult.size,
            corrupted: ossResult.corrupted,
          };
        } else {
          // Just UUID
          searchResult = await this.findFileByUuid(parsed);
        }
      } else {
        searchResult = { found: false, inOSS: false, inLocal: false };
        ref.error = `Cannot parse URL: ${ref.resolvedPath}`;
      }
    } else {
      searchResult = { found: false, inOSS: false, inLocal: false };
    }

    ref.existsInOSS = searchResult.inOSS;
    ref.existsInLocal = searchResult.inLocal;
    ref.localOnly = !searchResult.inOSS && searchResult.inLocal;
    ref.resolvedPath = searchResult.path || ref.resolvedPath;
    ref.fileSize = searchResult.fileSize;
    ref.corrupted = searchResult.corrupted;

    // File is valid only if in OSS AND not corrupted
    ref.exists = searchResult.inOSS && !searchResult.corrupted;

    if (searchResult.inOSS) {
      if (searchResult.corrupted) {
        ref.storageType = 'oss';
        ref.error = `CORRUPTED: File exists in OSS but is too small (${searchResult.fileSize} bytes)`;
      } else {
        ref.storageType = 'oss';
      }
    } else if (searchResult.inLocal) {
      ref.storageType = 'filesystem';
      ref.error = 'WARNING: File exists only in local filesystem, not in OSS';
    } else {
      ref.storageType = 'none';
      if (!ref.error) {
        ref.error = 'File not found in OSS or local storage';
      }
    }

    return ref;
  }

  /**
   * Validate all quizzes with images
   */
  private async validateQuizzes(): Promise<void> {
    if (!this.pool) {
      throw new Error('Database not initialized');
    }

    const query = sql.unsafe`
      SELECT
        id::text as id,
        question,
        options,
        images
      FROM kedge_practice.quizzes
      WHERE
        question ~ '\\{\\{ima?ge?:.*?\\}\\}'
        OR options::text ~ '\\{\\{ima?ge?:.*?\\}\\}'
        OR (images IS NOT NULL AND jsonb_array_length(images) > 0)
      ORDER BY id
    `;

    const result = await this.pool.query(query);
    const quizzes = result.rows as unknown as QuizRow[];

    const countResult = await this.pool.query(sql.unsafe`
      SELECT COUNT(*)::int as count FROM kedge_practice.quizzes
    `);
    this.report.summary.totalQuizzes = (countResult.rows[0] as any).count;

    if (!config.jsonOnly) {
      console.log(`\nüîç Found ${quizzes.length} quizzes with potential image references`);
      console.log(`üìä Total quizzes in database: ${this.report.summary.totalQuizzes}\n`);
    }

    for (const quiz of quizzes) {
      const textToScan = [
        quiz.question,
        ...(quiz.options || []).filter(Boolean),
      ].join(' ');

      const refs = this.extractImageReferences(textToScan, quiz.images);

      if (refs.length === 0 && (!quiz.images || quiz.images.length === 0)) {
        continue;
      }

      for (let i = 0; i < refs.length; i++) {
        refs[i] = await this.validateImageReference(refs[i], quiz.images);
      }

      const validImages = refs.filter(r => r.exists).length; // exists = in OSS AND not corrupted
      const missingImages = refs.filter(r => !r.existsInOSS && !r.existsInLocal).length;
      const localOnlyImages = refs.filter(r => r.localOnly).length;
      const corruptedImages = refs.filter(r => r.corrupted).length;

      const quizResult: QuizValidationResult = {
        quizId: quiz.id,
        question: quiz.question.substring(0, 100) + (quiz.question.length > 100 ? '...' : ''),
        imageReferences: refs,
        totalImages: refs.length,
        validImages,
        missingImages,
        localOnlyImages,
        corruptedImages,
      };

      this.report.details.push(quizResult);
      this.report.summary.quizzesWithImages++;
      this.report.summary.totalImageReferences += refs.length;
      this.report.summary.validImages += validImages;
      this.report.summary.missingImages += missingImages;
      this.report.summary.localOnlyImages += localOnlyImages;
      this.report.summary.corruptedImages += corruptedImages;

      if (missingImages > 0) {
        this.report.summary.quizzesWithMissingImages++;
      }
      if (localOnlyImages > 0) {
        this.report.summary.quizzesWithLocalOnlyImages++;
      }
      if (corruptedImages > 0) {
        this.report.summary.quizzesWithCorruptedImages++;
      }

      this.log(`  Quiz ${quiz.id}: OSS=${validImages}, Corrupted=${corruptedImages}, Local-only=${localOnlyImages}, Missing=${missingImages}`);
    }
  }

  /**
   * Generate CSV content
   */
  private generateCSV(): string {
    const headers = ['quiz_id', 'question_preview', 'placeholder', 'type', 'status', 'file_size', 'resolved_path', 'error'];
    const rows: string[][] = [headers];

    for (const quiz of this.report.details) {
      for (const ref of quiz.imageReferences) {
        // Include corrupted, local-only, and missing files
        if (!ref.exists || ref.corrupted || ref.localOnly) {
          let status = 'MISSING';
          if (ref.corrupted) {
            status = 'CORRUPTED';
          } else if (ref.localOnly) {
            status = 'LOCAL_ONLY';
          }

          rows.push([
            quiz.quizId,
            `"${quiz.question.replace(/"/g, '""')}"`,
            ref.placeholder,
            ref.type,
            status,
            ref.fileSize !== undefined ? String(ref.fileSize) : '',
            ref.resolvedPath || '',
            ref.error || '',
          ]);
        }
      }
    }

    return rows.map(row => row.join(',')).join('\n');
  }

  /**
   * Export reports to files
   */
  private async exportReports(): Promise<void> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const jsonFile = `quiz-image-validation-${timestamp}.json`;
    const csvFile = `missing-images-${timestamp}.csv`;

    await fs.promises.writeFile(jsonFile, JSON.stringify(this.report, null, 2), 'utf-8');
    await fs.promises.writeFile(csvFile, this.generateCSV(), 'utf-8');

    if (!config.jsonOnly) {
      console.log(`\n‚úÖ Reports exported:`);
      console.log(`   - ${jsonFile} (complete report)`);
      console.log(`   - ${csvFile} (missing/local-only images)`);
    }
  }

  /**
   * Print console summary
   */
  private printSummary(): void {
    if (config.jsonOnly) {
      console.log(JSON.stringify(this.report, null, 2));
      return;
    }

    console.log('\n=== QuizÂõæÁâáÈ™åËØÅÊä•Âëä ===');
    console.log(`Êó∂Èó¥: ${this.report.timestamp}\n`);

    console.log('üìä ÊëòË¶ÅÁªüËÆ°:');
    console.log(`  ÊÄªQuizÊï∞Èáè: ${this.report.summary.totalQuizzes}`);
    console.log(`  Âê´ÂõæÁâáQuiz: ${this.report.summary.quizzesWithImages}`);
    console.log(`  ÂõæÁâáÂºïÁî®ÊÄªÊï∞: ${this.report.summary.totalImageReferences}`);
    console.log(`  ‚úÖ Âú®OSS‰∏≠ÊúâÊïà: ${this.report.summary.validImages}`);
    console.log(`  üî¥ OSS‰∏≠Â∑≤ÊçüÂùè: ${this.report.summary.corruptedImages}`);
    console.log(`  ‚ö†Ô∏è  ‰ªÖÊú¨Âú∞Â≠òÂú®: ${this.report.summary.localOnlyImages}`);
    console.log(`  ‚ùå ÂÆåÂÖ®Áº∫Â§±: ${this.report.summary.missingImages}`);

    // Show corrupted files (files in OSS but too small)
    if (this.report.summary.corruptedImages > 0) {
      console.log('\nüî¥ Â∑≤ÊçüÂùèÁöÑÂõæÁâá (Êñá‰ª∂Â§™Â∞è, <100 bytes):');
      for (const quiz of this.report.details) {
        const corruptedRefs = quiz.imageReferences.filter(r => r.corrupted);
        if (corruptedRefs.length > 0) {
          console.log(`\nQuiz ID: ${quiz.quizId}`);
          console.log(`  È¢òÁõÆ: ${quiz.question}`);
          for (const ref of corruptedRefs) {
            console.log(`  üî¥ ${ref.placeholder} -> ${ref.resolvedPath || 'unknown'} (${ref.fileSize} bytes)`);
          }
        }
      }
    }

    if (this.report.summary.localOnlyImages > 0) {
      console.log('\n‚ö†Ô∏è  ‰ªÖÊú¨Âú∞Â≠òÂú®ÁöÑÂõæÁâá (ÈúÄË¶ÅËøÅÁßªÂà∞OSS):');
      for (const quiz of this.report.details) {
        const localOnlyRefs = quiz.imageReferences.filter(r => r.localOnly);
        if (localOnlyRefs.length > 0) {
          console.log(`\nQuiz ID: ${quiz.quizId}`);
          console.log(`  È¢òÁõÆ: ${quiz.question}`);
          for (const ref of localOnlyRefs) {
            console.log(`  ‚ö†Ô∏è  ${ref.placeholder} -> ${ref.resolvedPath || 'unknown path'}`);
          }
        }
      }
    }

    if (this.report.summary.missingImages > 0) {
      console.log('\n‚ùå ÂÆåÂÖ®Áº∫Â§±ÁöÑÂõæÁâá:');
      for (const quiz of this.report.details) {
        const missingRefs = quiz.imageReferences.filter(r => !r.existsInOSS && !r.existsInLocal);
        if (missingRefs.length > 0) {
          console.log(`\nQuiz ID: ${quiz.quizId}`);
          console.log(`  È¢òÁõÆ: ${quiz.question}`);
          for (const ref of missingRefs) {
            console.log(`  ‚ùå ${ref.placeholder} - ${ref.error || 'Not found'}`);
          }
        }
      }
    }

    if (this.report.summary.missingImages === 0 &&
        this.report.summary.localOnlyImages === 0 &&
        this.report.summary.corruptedImages === 0) {
      console.log('\n‚úÖ ÊâÄÊúâÂõæÁâáÂùáÂ∑≤Â≠òÂÇ®Âú®OSS‰∏≠‰∏îÂÆåÊï¥ÔºÅ');
    }
  }

  /**
   * Main validation function
   */
  public async validate(): Promise<void> {
    if (!config.jsonOnly) {
      console.log('üöÄ Starting quiz image validation...\n');
      console.log(`üìÅ Local storage root: ${config.storageRoot}`);
      console.log(`‚òÅÔ∏è  OSS enabled: ${config.ossEnabled}`);
      if (config.ossEnabled) {
        console.log(`‚òÅÔ∏è  OSS bucket: ${config.oss.bucket}`);
        console.log(`‚òÅÔ∏è  OSS path prefix: ${config.oss.pathPrefix}`);
      }
    }

    // Initialize OSS (required)
    if (!this.initOSS()) {
      console.error('\n‚ö†Ô∏è  Running without OSS - can only check local filesystem');
    }

    // Initialize database
    if (!(await this.initDatabase())) {
      process.exit(1);
    }

    try {
      await this.validateQuizzes();
      this.printSummary();
      await this.exportReports();

      // Exit code: 1 if any missing or corrupted, 0 otherwise (local-only is warning, not error)
      const exitCode = (this.report.summary.missingImages > 0 || this.report.summary.corruptedImages > 0) ? 1 : 0;
      process.exit(exitCode);
    } catch (error) {
      console.error('‚ùå Validation failed:', error);
      process.exit(1);
    } finally {
      if (this.pool) {
        await this.pool.end();
      }
    }
  }
}

// Help message
function showHelp(): void {
  console.log('Quiz Image Validation Script');
  console.log('');
  console.log('Validates that quiz image references exist in OSS storage.');
  console.log('Images only in local filesystem will be flagged as warnings.');
  console.log('');
  console.log('Usage: ts-node validate-quiz-images.ts [options]');
  console.log('');
  console.log('Options:');
  console.log('  --verbose       Show detailed progress');
  console.log('  --json-only     Only output JSON report (no console summary)');
  console.log('  --help          Show this help message');
  console.log('');
  console.log('Environment variables:');
  console.log('  NODE_DATABASE_URL           PostgreSQL connection string (required)');
  console.log('  QUIZ_STORAGE_PATH           Path to local file storage');
  console.log('  ALIYUN_OSS_ACCESS_KEY_ID    OSS access key (required)');
  console.log('  ALIYUN_OSS_ACCESS_KEY_SECRET OSS secret key (required)');
  console.log('  ALIYUN_OSS_BUCKET           OSS bucket name (required)');
  console.log('  ALIYUN_OSS_REGION           OSS region');
  console.log('  ALIYUN_OSS_ENDPOINT         OSS endpoint');
  console.log('  ALIYUN_OSS_PATH_PREFIX      OSS path prefix (default: quiz-attachments)');
}

// Main execution
async function main(): Promise<void> {
  if (process.argv.includes('--help')) {
    showHelp();
    process.exit(0);
  }

  const validator = new QuizImageValidator();
  await validator.validate();
}

main().catch(error => {
  console.error('‚ùå Fatal error:', error);
  process.exit(1);
});
